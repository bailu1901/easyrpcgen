using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CodeGenerator;


public static partial class  CSharpCodeGenerator
{
	public static void GrainInterface(TextWriter writer, string ClassName, string prefix, List<Function> Functions,bool needrv=true)
	{
		writer.WriteLine("// Generated by the rpc compiler.  DO NOT EDIT!");
		writer.WriteLine("using System;");
		writer.WriteLine("using System.Collections;");
		writer.WriteLine("using System.Threading.Tasks;");
		writer.WriteLine("using System.Collections.Generic;");
		writer.WriteLine("using Orleans;");
		writer.WriteLine("using Network;");
		writer.WriteLine("using DataContract;");
		writer.WriteLine();
		writer.WriteLine("namespace " + "GrainInterface");
		writer.WriteLine("{");
		writer.WriteLine("");
		writer.WriteLine("    public partial interface " + ClassName + ": IGrainWithIntegerKey");
		writer.WriteLine("    {");
		foreach (Function current in Functions)
		{
			writer.Write(Utility.CreateCSharpComment("        ", current.Comment));

			var retType = needrv
				? ("Task<ReturnValues<" + TypeDef.ConvertProtoType2CSType(current.RetType) + ">>")
				: ("Task<" + TypeDef.ConvertProtoType2CSType(current.RetType) + ">");
			var retString = (0 == current.RetType.CompareTo("void")) ? "Task " : retType;
			var funcLine = string.Concat(new string[]
			{
				"        ",
				retString,
				current.FunctionName,
				"("
			});
			for (int i = 0; i< current.Args.Count; i++)
			//foreach (var argument in current.Args)
			{
				var argument = current.Args[i];
				funcLine = string.Concat(funcLine, 
					
					TypeDef.ConvertProtoType2CSType(argument.Type),
					" ",
					argument.Name);
				if (i != current.Args.Count-1)
				{
					funcLine += ", ";
				}
			}
			funcLine += ");";
			writer.WriteLine(funcLine);
			
			writer.WriteLine();	
		}
		writer.WriteLine("    }");
		writer.WriteLine("}");
	}

}

